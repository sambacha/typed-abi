{"version":3,"file":"twos-complement.js","names":["fromTwosComplement","buffer","bufferValue","toBuffer","value","byte","BigInt","asIntN","length","toTwosComplement","Uint8Array","i","Number","asUintN","reverse"],"sources":["../../../src/utils/twos-complement.ts"],"sourcesContent":["import { toBuffer } from './buffer';\n\n/**\n * Get a bigint from a two's complement encoded buffer or hexadecimal string.\n *\n * @param buffer The buffer to get the number for.\n * @return The parsed number.\n */\nexport const fromTwosComplement = (buffer: string | Uint8Array): bigint => {\n  const bufferValue = toBuffer(buffer);\n\n  let value = 0n;\n  for (const byte of bufferValue) {\n    value = (value << 8n) + BigInt(byte);\n  }\n\n  return BigInt.asIntN(bufferValue.length * 8, value);\n};\n\n/**\n * Get a two's complement encoded buffer from a bigint.\n *\n * @param value The number to get the buffer for.\n * @param length The number of bytes to pad the buffer to.\n * @return The two's complement encoded buffer.\n */\nexport const toTwosComplement = (value: bigint, length: number): Uint8Array => {\n  const buffer = new Uint8Array(length);\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] = Number(BigInt.asUintN(8, value));\n    value = value >> 8n;\n  }\n\n  return buffer.reverse();\n};\n"],"mappings":";;;;;;;AAAA;;AAQO,MAAMA,kBAAkB,GAAIC,MAAD,IAAyC;EACzE,MAAMC,WAAW,GAAG,IAAAC,gBAAA,EAASF,MAAT,CAApB;EAEA,IAAIG,KAAK,GAAG,EAAZ;;EACA,KAAK,MAAMC,IAAX,IAAmBH,WAAnB,EAAgC;IAC9BE,KAAK,GAAG,CAACA,KAAK,IAAI,EAAV,IAAgBE,MAAM,CAACD,IAAD,CAA9B;EACD;;EAED,OAAOC,MAAM,CAACC,MAAP,CAAcL,WAAW,CAACM,MAAZ,GAAqB,CAAnC,EAAsCJ,KAAtC,CAAP;AACD,CATM;;;;AAkBA,MAAMK,gBAAgB,GAAG,CAACL,KAAD,EAAgBI,MAAhB,KAA+C;EAC7E,MAAMP,MAAM,GAAG,IAAIS,UAAJ,CAAeF,MAAf,CAAf;;EACA,KAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGV,MAAM,CAACO,MAA3B,EAAmCG,CAAC,EAApC,EAAwC;IACtCV,MAAM,CAACU,CAAD,CAAN,GAAYC,MAAM,CAACN,MAAM,CAACO,OAAP,CAAe,CAAf,EAAkBT,KAAlB,CAAD,CAAlB;IACAA,KAAK,GAAGA,KAAK,IAAI,EAAjB;EACD;;EAED,OAAOH,MAAM,CAACa,OAAP,EAAP;AACD,CARM"}