{"version":3,"file":"packer.js","names":["getParser","type","parsers","address","array","bool","bytes","fixedBytes","function","fn","number","string","tuple","parser","Object","values","find","isType","Error","isDynamicParser","isDynamic","pack","types","buffer","Uint8Array","length","staticBuffer","dynamicBuffer","pointers","reduce","index","value","encode","newStaticBuffer","concat","newDynamicBuffer","position","pointer","dynamicStart","updatedBuffer","target","offset","toBuffer","set","unpack","iterator","iterate","map","skip","done","next","Number","toNumber","subarray","decode"],"sources":["../../src/packer.ts"],"sourcesContent":["import { iterate } from './iterator';\nimport { address, array, bool, bytes, fixedBytes, fn, number, string, tuple } from './parsers';\nimport { PackState, Parser } from './types';\nimport { concat, set, toBuffer, toNumber } from './utils';\n\n/**\n * Get the parser for the specified type. This will throw if there is no parser for the specified type.\n *\n * @param type The type to get a parser for.\n * @return The parser.\n */\nexport const getParser = (type: string): Parser => {\n  const parsers: { [key: string]: Parser } = {\n    address,\n    array,\n    bool,\n    bytes,\n    fixedBytes,\n    function: fn,\n    number,\n    string,\n    tuple\n  };\n\n  if (parsers[type]) {\n    return parsers[type];\n  }\n\n  const parser = Object.values(parsers).find((parser) => parser.isType?.(type));\n  if (parser) {\n    return parser;\n  }\n\n  throw new Error(`Type \"${type}\" is not supported`);\n};\n\n/**\n * Check if the specified parser is dynamic, for the provided types. This is primarily used for parsing tuples, where\n * a tuple can be dynamic based on the types. For other parsers, it will simply use the set `isDynamic` value.\n *\n * @param parser The parser to check.\n * @param type The type to check the parser with.\n * @return Whether the parser is dynamic.\n */\nexport const isDynamicParser = (parser: Parser, type: string): boolean => {\n  const isDynamic = parser.isDynamic;\n  if (typeof isDynamic === 'function') {\n    return isDynamic(type);\n  }\n\n  return isDynamic;\n};\n\n/**\n * Pack the provided values in a buffer, encoded with the specified types. If a buffer is specified, the resulting value\n * will be concatenated with the buffer.\n *\n * @param types The types to use for encoding.\n * @param values The values to encode.\n * @param [buffer] The buffer to concatenate with.\n * @return The resulting encoded buffer.\n */\nexport const pack = (types: string[], values: unknown[], buffer: Uint8Array = new Uint8Array()): Uint8Array => {\n  if (types.length !== values.length) {\n    throw new Error('The length of the types and values must be equal');\n  }\n\n  const { staticBuffer, dynamicBuffer, pointers } = types.reduce<PackState>(\n    ({ staticBuffer, dynamicBuffer, pointers }, type, index) => {\n      const parser = getParser(type);\n      const value = values[index];\n\n      if (!isDynamicParser(parser, type)) {\n        return {\n          staticBuffer: parser.encode({ buffer: staticBuffer, value, type }),\n          dynamicBuffer,\n          pointers\n        };\n      }\n\n      const newStaticBuffer = concat([staticBuffer, new Uint8Array(32)]);\n      const newDynamicBuffer = parser.encode({ buffer: dynamicBuffer, value, type });\n\n      return {\n        staticBuffer: newStaticBuffer,\n        dynamicBuffer: newDynamicBuffer,\n        pointers: [...pointers, { position: staticBuffer.length, pointer: dynamicBuffer.length }]\n      };\n    },\n    { staticBuffer: new Uint8Array(), dynamicBuffer: new Uint8Array(), pointers: [] }\n  );\n\n  const dynamicStart = staticBuffer.length;\n  const updatedBuffer = pointers.reduce((target, { pointer, position }) => {\n    const offset = toBuffer(dynamicStart + pointer);\n    return set(target, offset, position);\n  }, staticBuffer);\n\n  return concat([buffer, updatedBuffer, dynamicBuffer]);\n};\n\nexport const unpack = (types: string[], buffer: Uint8Array): unknown[] => {\n  const iterator = iterate(buffer);\n\n  return types.map((type) => {\n    const {\n      value: { value, skip },\n      done\n    } = iterator.next();\n    if (done) {\n      throw new Error('Element is out of range');\n    }\n\n    const parser = getParser(type);\n    const isDynamic = isDynamicParser(parser, type);\n\n    if (isDynamic) {\n      const pointer = Number(toNumber(value.subarray(0, 32)));\n      const target = buffer.subarray(pointer);\n\n      return parser.decode({ type, value: target, skip });\n    }\n\n    return parser.decode({ type, value, skip });\n  });\n};\n"],"mappings":"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"}