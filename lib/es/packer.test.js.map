{"version":3,"file":"packer.test.js","names":["getParser","isDynamicParser","pack","unpack","array","number","string","tuple","fromHex","toHex","describe","it","expect","toBe","toThrow","buffer","toStrictEqual"],"sources":["../../src/packer.test.ts"],"sourcesContent":["import { getParser, isDynamicParser, pack, unpack } from './packer';\nimport { array, number, string, tuple } from './parsers';\nimport { fromHex, toHex } from './utils';\n\ndescribe('getParser', () => {\n  it('returns a parser for the specified type', () => {\n    expect(getParser('uint256[]')).toBe(array);\n    expect(getParser('(uint256)')).toBe(tuple);\n    expect(getParser('uint256')).toBe(number);\n    expect(getParser('uint')).toBe(number);\n    expect(getParser('string')).toBe(string);\n  });\n\n  it('throws for invalid types', () => {\n    expect(() => getParser('foo')).toThrow();\n  });\n});\n\ndescribe('isDynamicParser', () => {\n  it('checks if a parser is dynamic based on the type', () => {\n    expect(isDynamicParser(tuple, '(uint256,string)')).toBe(true);\n    expect(isDynamicParser(string, 'string')).toBe(true);\n    expect(isDynamicParser(array, 'string[]')).toBe(true);\n\n    expect(isDynamicParser(tuple, '(uint256)')).toBe(false);\n    expect(isDynamicParser(number, 'uint256')).toBe(false);\n    expect(isDynamicParser(number, 'bytes32')).toBe(false);\n  });\n});\n\ndescribe('pack', () => {\n  it('encodes a buffer using the specified types', () => {\n    expect(toHex(pack(['string[]'], [['foo bar', 'baz qux']]))).toBe(\n      '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000007666f6f2062617200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000762617a2071757800000000000000000000000000000000000000000000000000'\n    );\n    expect(toHex(pack(['uint256', 'uint256'], [32n, 2n]))).toBe(\n      '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002'\n    );\n  });\n});\n\ndescribe('unpack', () => {\n  it('decodes a buffer using the specified types', () => {\n    const buffer = fromHex(\n      '00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000007666f6f2062617200000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000762617a2071757800000000000000000000000000000000000000000000000000'\n    );\n\n    expect(unpack(['string[]'], buffer)).toStrictEqual([['foo bar', 'baz qux']]);\n    expect(unpack(['uint256', 'uint256'], buffer)).toStrictEqual([32n, 2n]);\n  });\n\n  it('throws if the buffer is out of range', () => {\n    const buffer = fromHex('0000000000000000000000000000000000000000000000000000000000000020');\n    expect(() => unpack(['uint256', 'uint256'], buffer)).toThrow();\n  });\n});\n"],"mappings":"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"}