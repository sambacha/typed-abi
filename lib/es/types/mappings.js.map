{"version":3,"file":"mappings.js","names":[],"sources":["../../../src/types/mappings.ts"],"sourcesContent":["import { address, bool, bytes, fn, number, string } from '../parsers';\nimport type { Parser } from './parser';\n\n// prettier-ignore\ntype ByteLength = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32;\n// prettier-ignore\ntype IntegerLength = 8 | 16 | 24 | 32 | 40 | 48 | 56 | 64 | 72 | 80 | 88 | 96 | 104 | 112 | 120 | 128 | 136 | 144 | 152 | 160 | 168 | 176 | 184 | 192 | 200 | 208 | 216 | 224 | 232 | 240 | 248 | 256;\n\ntype Bytes = `bytes${ByteLength}`;\ntype Integer = `int${IntegerLength}`;\ntype UnsignedInteger = `uint${IntegerLength}`;\n\nexport type Type = keyof OutputTypeMap;\nexport type TypeMapper<I extends any[], T = OutputTypeMap> = Mapper<T, I>;\n\n/**\n * An object type with most possible ABI types, and their respective TypeScript type. Note that some dynamic types, like\n * `<type>[<length>]` and `fixed<M>x<N>` are not supported, and `unknown` is used instead.\n */\nexport type OutputTypeMap = WithArrayTypes<MapToOutput<TypeMap>>;\n\n/**\n * An object type with most possible ABI types, and their respective TypeScript type. Note that some dynamic types, like\n * `<type>[<length>]` and `fixed<M>x<N>` are not supported, and `unknown` is used instead.\n *\n * Accepts multiple input types for certain ABI types, like strings, bytes, numbers.\n */\nexport type InputTypeMap = WithArrayTypes<MapToInput<TypeMap>>;\n\n/**\n * Generic type map which is used to generate the input and output type map.\n */\ntype TypeMap = {\n  address: ExtractGeneric<typeof address>;\n  bool: ExtractGeneric<typeof bool>;\n  bytes: ExtractGeneric<typeof bytes>;\n  function: ExtractGeneric<typeof fn>;\n  int: ExtractGeneric<typeof number>;\n  string: ExtractGeneric<typeof string>;\n  uint: ExtractGeneric<typeof number>;\n} & DynamicType<Bytes, ExtractGeneric<typeof bytes>> &\n  DynamicType<Integer, ExtractGeneric<typeof number>> &\n  DynamicType<UnsignedInteger, ExtractGeneric<typeof number>>;\n\n/**\n * Helper type to generate an object type from a union.\n */\ntype DynamicType<K extends string, T> = {\n  [key in K]: T;\n};\n\n/**\n * Helper type that maps the input `I` to the types `T`.\n */\ntype Mapper<T, I extends any[]> = {\n  [K in keyof I]: I[K] extends I[number] ? T[I[K]] : unknown;\n};\n\n/**\n * Helper type that maps a tuple to the first element.\n */\nexport type MapToInput<T extends Record<string, [unknown, unknown]>> = {\n  [K in keyof T]: T[K][0];\n};\n\n/**\n * Helper type that maps a tuple to the second element.\n */\nexport type MapToOutput<T extends Record<string, [unknown, unknown]>> = {\n  [K in keyof T]: T[K][1];\n};\n\n/**\n * Helper type that adds an array type for each of the specified keys and types.\n */\ntype WithArrayTypes<T> = T &\n  {\n    [K in keyof T as `${string & K}[]`]: Array<T[K]>;\n  };\n\n/**\n * Helper type that extracts the input or output from a Parser;.\n */\ntype ExtractGeneric<T> = T extends Parser<infer I, infer O> ? [I, O] : never;\n"],"mappings":""}