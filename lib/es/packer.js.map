{"version":3,"file":"packer.js","names":["iterate","address","array","bool","bytes","fixedBytes","fn","number","string","tuple","concat","set","toBuffer","toNumber","getParser","type","parsers","function","parser","Object","values","find","isType","Error","isDynamicParser","isDynamic","pack","types","buffer","Uint8Array","length","staticBuffer","dynamicBuffer","pointers","reduce","index","value","encode","newStaticBuffer","newDynamicBuffer","position","pointer","dynamicStart","updatedBuffer","target","offset","unpack","iterator","map","skip","done","next","Number","subarray","decode"],"sources":["../../src/packer.ts"],"sourcesContent":["import { iterate } from './iterator';\nimport { address, array, bool, bytes, fixedBytes, fn, number, string, tuple } from './parsers';\nimport type { PackState, Parser } from './types';\nimport { concat, set, toBuffer, toNumber } from './utils';\n\n/**\n * Get the parser for the specified type. This will throw if there is no parser for the specified type.\n *\n * @param type The type to get a parser for.\n * @return The parser.\n */\nexport const getParser = (type: string): Parser => {\n  const parsers: { [key: string]: Parser } = {\n    address,\n    array,\n    bool,\n    bytes,\n    fixedBytes,\n    function: fn,\n    number,\n    string,\n    tuple\n  };\n\n  if (parsers[type]) {\n    return parsers[type];\n  }\n\n  const parser = Object.values(parsers).find((parser) => parser.isType?.(type));\n  if (parser) {\n    return parser;\n  }\n\n  throw new Error(`Type \"${type}\" is not supported`);\n};\n\n/**\n * Check if the specified parser is dynamic, for the provided types. This is primarily used for parsing tuples, where\n * a tuple can be dynamic based on the types. For other parsers, it will simply use the set `isDynamic` value.\n *\n * @param parser The parser to check.\n * @param type The type to check the parser with.\n * @return Whether the parser is dynamic.\n */\nexport const isDynamicParser = (parser: Parser, type: string): boolean => {\n  const isDynamic = parser.isDynamic;\n  if (typeof isDynamic === 'function') {\n    return isDynamic(type);\n  }\n\n  return isDynamic;\n};\n\n/**\n * Pack the provided values in a buffer, encoded with the specified types. If a buffer is specified, the resulting value\n * will be concatenated with the buffer.\n *\n * @param types The types to use for encoding.\n * @param values The values to encode.\n * @param [buffer] The buffer to concatenate with.\n * @return The resulting encoded buffer.\n */\nexport const pack = (types: string[], values: unknown[], buffer: Uint8Array = new Uint8Array()): Uint8Array => {\n  if (types.length !== values.length) {\n    throw new Error('The length of the types and values must be equal');\n  }\n\n  const { staticBuffer, dynamicBuffer, pointers } = types.reduce<PackState>(\n    ({ staticBuffer, dynamicBuffer, pointers }, type, index) => {\n      const parser = getParser(type);\n      const value = values[index];\n\n      if (!isDynamicParser(parser, type)) {\n        return {\n          staticBuffer: parser.encode({ buffer: staticBuffer, value, type }),\n          dynamicBuffer,\n          pointers\n        };\n      }\n\n      const newStaticBuffer = concat([staticBuffer, new Uint8Array(32)]);\n      const newDynamicBuffer = parser.encode({ buffer: dynamicBuffer, value, type });\n\n      return {\n        staticBuffer: newStaticBuffer,\n        dynamicBuffer: newDynamicBuffer,\n        pointers: [...pointers, { position: staticBuffer.length, pointer: dynamicBuffer.length }]\n      };\n    },\n    { staticBuffer: new Uint8Array(), dynamicBuffer: new Uint8Array(), pointers: [] }\n  );\n\n  const dynamicStart = staticBuffer.length;\n  const updatedBuffer = pointers.reduce((target, { pointer, position }) => {\n    const offset = toBuffer(dynamicStart + pointer);\n    return set(target, offset, position);\n  }, staticBuffer);\n\n  return concat([buffer, updatedBuffer, dynamicBuffer]);\n};\n\nexport const unpack = (types: string[], buffer: Uint8Array): unknown[] => {\n  const iterator = iterate(buffer);\n\n  return types.map((type) => {\n    const {\n      value: { value, skip },\n      done\n    } = iterator.next();\n    if (done) {\n      throw new Error('Element is out of range');\n    }\n\n    const parser = getParser(type);\n    const isDynamic = isDynamicParser(parser, type);\n\n    if (isDynamic) {\n      const pointer = Number(toNumber(value.subarray(0, 32)));\n      const target = buffer.subarray(pointer);\n\n      return parser.decode({ type, value: target, skip });\n    }\n\n    return parser.decode({ type, value, skip });\n  });\n};\n"],"mappings":"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"}